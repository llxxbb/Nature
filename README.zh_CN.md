# Nature

Nature 是一种新的**数据驱动**的**面向业务**的用于构建大型系统的**支撑平台**。Nature 使用下游**“自然选择”**上游（整体上还是自下而上）的方式来替代传统的**“上游控制下游”**方式来构建系统，从而将**复杂度由“一对多”变为“一对一”**，大幅度减少模块间的耦合，并在不断选择中实现整个系统的**“进化”**，这也是本项目名称的寓意所在。而这种开发方式将为系统生命周期的各个阶段减负。

请不要认为这是个复杂的项目，理论足够简单的核心才能支撑起复杂和庞大的应用体系，就像量子构成我们的世界一样。当然我只是一个推动者，使Nature 变得简单，可能离真正的简单还很遥远。

## 相关概念

Nature 只关注两样东西：一个是**数据**，一个是数据间的**关系**。数据其实就是**业务目标**，而关系是可以让你一个接一个**实现这些目标的跳板**。跳板不是方法，Nature不告诉你怎么做。

### 数据为什么是“目标”？

宏观上讲，系统就是为了处理数据，显示器里看到的都是数据，系统间交互的也都是数据，所以**系统为数据而生**。从微观上讲，一个方法输入的是数据，输出的也是数据，**方法存在的意义就是处理数据**，数据才是我们想要的东西，所以**数据和目标是等同的**。**数据是系统的灵魂，是企业的灵魂**。

# 需梳理

### 传统开发方式的问题

**把控目标的人有些脱节**

这就要求设计人员和研发管理认识的设计必须与业务架构相吻合，而现实情况是具有这样能力的人太少，尤其是能够预留可能变化的空间而不只是满足现状的设计能力。领域驱动是一个好的概念，但这里的核心是人：领域专家。这就很容易**导致系统出现结构性问题**。（为什么业务目标由业务人员定会不会更合理）

技术人员很容易将技术目标和业务合在一起解决，他们认为这是天经地义的事。

**目标失控**

目标是要落地的，落地是要功能化的，所以**日常开发任务充斥着功能性的需求**，为了解决这些功能性问题，我们经常偏离了目标。（用人去守护目标太辛苦）

**目标划分的边界**

一个宏观的目标必须划分成许多小目标来让多个团队协同实施。

**目标的约束力**

另外在一个大型系统里，我们即使把蓝图设计的很好，当把系统层层细分并由很多人共同参与设计实施的时候，子目标间的边界模糊，功能重叠，加上工期的限制，导致我们会做很多妥协，而**经过很多次妥协的系统将是乱象丛生**，许多大型系统的重要业务领域往往都会因此而彻底推翻重来好多次，才能走上正轨，成**本非常高昂**！具体表现为以下几个方面：

- 需求阶段受限于当前现状及对业务发展空间的预判，导致数据的概念及边界定义**不是十分准确**，且数据定义（目标范围的定义）的好坏十分依赖设计人员的抽象能力，这就为后续过程放大这个“不准确”留下了伏笔。

- 不准确还体现在设计说明书中的**数据定义是文本性**的，需要人的理解才能映射到系统上去，**很容易失真**；另外，各种文档与代码迭代同步很难，最后是懒得改，这就是为什么**代码是最好的文档**的由来。进一步加大失真现象的发生。
- **代码中的方法，其入参和出参都是结构而方法体是规则，方法体是功能实现，所有的东西都耦合在一起，代码成为数据的实际控制者。** 它会导致下面的问题产生：
  - 业务想变，代码变起来很难！
  - 入参、出参，很容易耦合借道的其他参数，**容易造成目标的迷失**，使迭代变得困难。

综合上面的问题和现象来看，目标对系统是一整弱约束，甚至反被系统拖累无法施展。

之所以发生这样的问题其根本原因在于**目标分解行为存在子目标边界模糊、重叠及实施过程的妥协**。具体表现为：

### （Nature 也不能避免一开始目标是清晰的）

- 

强迫业务人员拥有结构性思维，弱化功能性思维带来的约束，及时是设计人员主导。形成一个可共同理解的界面。

上面问题其原因就在于**应用架构不能很好的契合业务架构的需要**，甚至拖累业务的发展，更谈不上有力推动业务的发展。所以**传统开发方式严重制约了业务的发展，而且是无法避免的。**

关键点在于目标的把控上。

在传统开发方式下，企业的目标无形中被研发所制约，沟通、开发、维护成本高昂。而 **Nature 将目标和实现进行了彻底隔离，让懂业务的人直接掌控纯粹的业务数据，并指导开发，以**解决了传统开发方式的弊端；同时 **Nature 內建了一套完整的，统一的和广泛的能够对目标进行保驾护航的处理机制**，如幂等，重试，最终一致性等，大幅度简化了开发和维护成本。

### Nature 的数据表示

数据在Nature 里有两种形式：`Meta` 和 `Instance`。 `Meta` 表示业务对象的定义，而 `instance`则是业务对象的实例，也是你最终想要的业务数据。`Meta` 和 `Instance`相当于编程语言中的 `Class` 和 `Object`。

`Instance`可以由 Nature 外部输入或者由 `Relation`（下面会讲） 中定义的 `Converter` 转换而来。**`Instance` 数据一旦生成将无法改变**，对于`Stateful-Instance`数据 Nature 使用版本化技术来保证数据的不可变性。

### `Relation` 

`Meta` 和 `Meta` 是通过 `Relation` 来建立联系的，比如“订单”和“生产申请单”之间存在着直接的联系。 `Relation` 仅支持**”一对一“**这种形式，`Relation` 的这种形式有下面几个重要的好处：

- 这种形式只能是下游选择上游，不可能是上游控制下游，这就大幅度减少彼此之间的耦合，使得每块业务的开发维护变得轻松简单。
- “一对一”意味着一个输入对应一个输出，这就简化了 Nature与 `Converter` 的交互形式：[**y=f(x)**](doc_zh/help/architecture.md) 。
- 因为由 “控制” 变成了“选择”，相对于传统编程模式 If,else,switch 等控制语句在 Nature 模式下基本上消失了，所以业务系统的复杂性也随之降低，稳定性和可维护性随之提高。

`Relation` 通过“一对一”这种方式可以将所有的`Meta`串接成一个庞大的业务网，这**是业务系统的一个完整的实时的结构快照**。 `Relation` 能够强有力的将 “松散” 的 `Converter` 黏连在一起，发挥 1 + 1 > 2的效果。

### `Converter` 

关系建立起来之后，需要借助 `converter` 才能将源`instance`加工成为目标`instance`。`Converter`由业务系统来实现并被Nature调用。Nature中定义的每个`Relation`都需要一个独立的`Converter`来实现。

`Converter`将相关的 `Instance` 串接在一起，**构成一个完整的可视的可追溯的业务跟踪链条**。

## Nature 的价值

借助 Nature 可以实现**目标管理**，并大幅度减少达成目标的成本，主要表现为以下几个方面：

- **纯粹的目标**：Nature 中的`Meta`是对业务目标的抽象提纯，什么时候你都能得到一个干净的目标描述，并对开发构成强制约束，保证你的目标不会被淹没和迷失。
- **更准确的目标**。由业务人员直接表达，不需要设计人员和开发人员的多次翻译，摆脱功能性驱动的魔咒。
- **全局视图**：Nature 中的`Relation`是目标的连接，而非功能的连接。就像一个地球仪一样，所有的东西都在那里了，而不是飞机、轮船和火车。所以**管理者可以非常容易的从更高的视角去审视这些目标的合理性**，尤其适用于迭代开发。
- **快速迭代**：允许目标和实现独立迭代。Nature 的 `Meta` 用版本来管理变化，`Relation` 可以更换 `Converter`，没有任何技术障碍来妨碍你的变更。
- **简化的开发**。 有下面几个点：
  - 所有的`Converter`都是可插拔的，可替换的。
  - 不用关心数据的一致性、高并发、幂等、重试等事情，Nature 已经为你搞定了这些。
- Nature 可以节省你的时间和金钱，系统越大效果越明显。

## Nature 特性

### 可扩展性

* 分布式：每个节点都是职能对等的，可通过增加服务器来达到线性扩展。

### 可用性

* 数据一致性：Nature 生成的数据具有不变性，并实现最终一致性。
* 幂等：Nature 支持幂等

### 可靠性

* 重试：Nature 遇到环境问题可以自动重试。

## 与其他系统的区别

### 消息系统

Nature 中的“选择”是从消息系统中借鉴而来的，有点类似于消息系统的发布与订阅，但 Nature 与消息系统存在着本质的不同。消息系统仅仅是一种技术形式，他允许开发者既是球员（功能开发）又是裁判员（目标数据定义），其中的消息是暂态的，消息与消息之间没有必然的相关性，消息系统的本质是解耦两个技术过程。而 Nature 是面向业务的，不关心技术形态，其中的数据是永恒的，数据和数据间存在强相关性，Nature 中的“选择”衔接的是两个目标而不是过程，衔接的是真个业务网中的一个一个的里程碑。

### `workflow` 和 `BPMN` 

从业务流程控制来看，Nature 与 `workflow` 和 `BPMN` 有一定的相似之处。其重要区别在于后者告诉我们**怎么做（功能性驱动）**，“怎么做”是非常复杂的，具象的，迭代多了我们的**目标可能会迷失**。而 Nature 告诉我**需要什么**，而“需要什么”是简单但最为重要的更不会迷失，Nature 把“需要什么”放到了 `Meta` 里。这样我们就能**聚焦到真正重要的事情**上，并**让管理变得简单**。Nature 把怎么做交到了外部的 `Converter` 去处理，如何处理是不去管的。

### Faas 和 Serveless

Nature 和 `Converter` 协作的方式实际上可以看做是 FaaS(Function as a Service) 或者 Serveless 的一种形式，但我不想使用这个概念，因为`FaaS` 不是这个项目的主要设计意图，我没有看到 `FaaS` 是如何管理业务目标的。

## 深入了解Nature

[示例及功能讲解](https://github.com/llxxbb/Nature-Demo)

[架构说明](doc_zh\help\architecture.md)

`Meta`的具体使用方法请参考：[使用 Meta](doc_zh/help/meta.md)

`Relation`的具体使用方法请参考[使用 Relation](doc_zh/help/relation.md)

`Converter`的实现方法请参考[实现`Converter`](doc_zh/help/converter.md)

本系统还处于早期阶段

