# Nature

Nature 是一种基于**数据驱动**和**面向业务**的用于构建大型系统的**支撑平台**。Nature 使用下游**“自然选择”**上游的方式来替代传统的**“上游控制下游”**方式来构建系统，从而将**复杂度由“一对多”变为“一对一”**，这样既大幅度减少模块间的耦合，又简化了开发，提升了系统的健壮性和可维护性。使得系统在不断**选择**中实现**“进化”**。这也是本项目名称的寓意所在。这种新的开发方式将**为系统生命周期的各个阶段减负**。

数据既是企业架构的目标也是系统架构的目标，**Nature 紧紧的以数据为核心进行架构，有机的将业务架构和系统架构整合到一起**。

Nature 的使用者并不局限于研发，其最重要的用户是负责企业架构和（或）系统架构的人员。

请不要认为这是个复杂的项目，理论足够简单的核心才能支撑起复杂和庞大的应用体系，就像量子构成我们的世界一样。当然我只是一个推动者，可能离真正的简单还很遥远。

## 传统开发方式的问题

这也是 Nature 项目诞生的原因，让我们来看下：

### 目标保障的成本

系统要实现业务目标，**需要一整套软件工程为之保驾护航**。出于人员，管理和时间成本的考虑，我们往往会做不同程度的裁剪，再结合各种开发模式，如敏捷，以使得质量和成本之间达到一个平衡，但即使是这样也**远远高出编写代码本身的成本**。有已下几个原因：

- **目标是隐性的**，文档里的目标只能通过完成的系统来验证，所以目标管的范围变广，周期变长，成本也就上来了。
- **目标协同非常困难**。团队里每个人的认知都有局限性，而配置工具、开发模式等只是人脑的辅助。
- **目标的覆盖能力弱**。大型系统分解时，子目标间的边界模糊，功能重叠等问题在所难免，而这些经常被无意或刻意的疏忽。

### 支撑目标的能力

**需求里面往往充斥着功能性的描述！**这非常考验系统架构的能力，尤其是包容业务架构调整的能力。而**有这样能力的人太少**。领域驱动是一个好的概念，但领域驱动的核心也是人：领域专家。

### 被固化的业务目标

我们辛辛苦苦做出来的系统虽然支撑了目标，但同时也**把目标放到了牢笼里了**，这会导致下面的问题产生：

- 业务想变，代码变起来很难！
- **容易造成目标的迷失**，因为技术性代码可能远多于业务性的代码，目标被淹没了。

## Nature 的解决方式

由此可见，传统开发方式的目标管理存在着深层次的问题，其**本质问题是代码说明了一切！**使目标无法独善其身。而这些问题无法通过完善业务系统自身来解决，必须借助于外部机制， Nature 便是其中的一个选择。

Nature 只关注两样东西：一个是**业务数据**，一个是业务数据间的**关系**。业务数据其实就是**业务目标**，而关系是可以让你一个接一个**实现这些目标的跳板**。跳板不是方法，**Nature不告诉你怎么做而只是帮助你梳理你需要什么，以及达成目标的里程碑**。

### 业务数据的“目标”属性

宏观上讲，系统就是为了处理数据，显示器里看到的都是数据，系统间交互的也都是数据，所以**系统为数据而生，数据就是系统的目标**。从微观上讲，一个方法输入的是数据，输出的也是数据，**方法存在的意义就是处理数据，数据就是方法的目标**。由此可见数据才是我们想要的东西，所以**数据和目标是等同的**。所以**业务数据是系统的灵魂，是企业的灵魂**。业务数据管好了，目标也就管好了，而 Nature 就是为管理业务数据而生。

### Nature 从系统中剥离业务数据，使目标由隐性变为显性

**业务目标需在Nature 中以统一的方式预先定义**，才能在业务系统中使用。业务目标在Nature 里有两种形式：`Meta` 和 `Instance`，它们相当于编程语言中的 `Class` 和 `Object`。 `Meta` 表示业务目标的定义，业务目标的变动可以用`version` 来处理，以满足业务变化的灵活性。 `instance`则是业务目标的实例，也是你最终想要的业务数据。`Instance`可以由 Nature 外部输入或者由 `Relation`（下面会讲） 中定义的 `Converter` 转换而来。**`Instance` 数据一旦生成将无法改变**，对于`Stateful-Instance`数据 Nature 使用`state-version`技术来保证数据的不可变性。不可变性将是保证数据一致性和可追溯的有力保证。

### Nature 从系统中剥离业务关系，以肢解业务系统的复杂度。

业务系统之所以复杂，就是因为**逻辑交织在一起，彼此之间有太多的强依赖**，虽然用消息中间件可以缓解，但也只能是解决局部问题。而 Nature 将业务目标之间的关系也一并从业务系统中剥离，这样就从全局上解决了依赖问题。Nature 在肢解逻辑的同时，用 `Converter` 将所有的独立的逻辑强有力的粘合在一起，发挥1+1>2的作用。

Nature 用 `Relation`来表示关系，用于连接两个`Meta`。比如“订单”和“生产申请单”之间的关系。 `Relation` 仅支持**”一对一“**这种形式，`Relation` 的这种形式有下面几个重要的好处：

- 这种形式**只能是下游选择上游**，不可能是上游控制下游。相对于传统编程模式里的 If,else,switch 等控制语句在 Nature 模式下基本上消失了，所以业务系统的复杂性也随之降低，稳定性和可维护性随之提高。
- “一对一”意味着一个输入对应一个输出，这就简化了 Nature与 `Converter` 的交互形式：[**y=f(x)**](doc_zh/help/architecture.md) 。

### 业务系统变成一个个独立的`Converter` 

没有了业务目标和业务关系的业务系统将变的非常简单，里面基本上只有调用 Nature 的逻辑和 `Converter`实现了。Nature 中的`Relation` 需要借助 `converter` 才能将源`instance`加工成为目标`instance`。`Converter`在运行时将相关的 `Instance` 串接在一起，**构成一个完整的可视的可追溯的业务跟踪链条**。

## Nature 的价值

借助 Nature 可以实现**目标管理**，并将复杂的系统肢解成简单的代码块。使得目标与目标之间，目标与代码之间，代码与代码之间最低程度耦合。这给了业务充分变化发展的空间以及其他方面的价值，如：

### 纯粹而准确的目标

Nature 中的 `Meta` 是对业务目标的抽象提纯，她将不可见的灵魂从系统中提取出来并可视化了。她是干净、纯粹、直白的，且是业务人员容易理解的。这就降低了对高端人才的需求，不需要高端的技术人员从功能中抽象。也省去了同步文档和代码的工作，整个团队的认知从源头就可以很容易达成一致。自然，目标管理的范围和周期也大为减少。

Nature 强迫业务人员拥有结构性思维，弱化功能性思维对系统带来的伤害。即便是设计人员主导。也容易形成一个可共同理解的界面，**摆脱了功能性驱动的魔咒**。

Nature 中的目标会对开发构成强制约束。避免了被设计人员、开发人员等多次翻译所造成的失真，同时也避免了目标被淹没和迷失的风险。

### 全局视图

相对于传统开发模式，目标的可视化本身就是一件很困难的事，要想做到全面实时几乎是不太可能。而Nature 中的 `Relation` 将所有目标串接成一个庞大的业务网，这**是整个业务系统的一个完整的实时的结构快照**。她里面是没有功能，这使得**目标之间的推理变得清晰明了**，也就解决了目标覆盖的问题。就像一个地球仪一样，所有的东西都在那里，但里面没有飞机、轮船和火车等功能性的东西，让你聚焦你想要的东西。这样**管理者可以非常容易的从更高的视角去审视这些干净的目标的合理性**。

### 快速迭代

业务逻辑之间的耦合性被 Nature 的 `Relation` 肢解后，每块的业务逻辑非常独立，而且逻辑本身都是可以插拔的，这些逻辑也不需要关心像数据的一致性、高并发、幂等、重试等事情，因为Nature 已经为你搞定了这些。Nature 就像是火车轨道，而`Converter`就是轨道上的火车，**不需要方向盘就可以跑的非常准非常块**。

### Nature 可以节省时间和金钱，系统越大效果越明显

越复杂的系统链路越长，逻辑耦合也就越严重，成本消耗也就越严重。

## 与其他系统的区别

### 消息系统

Nature 中的“选择”是从消息系统中借鉴而来的，有点类似于消息系统的发布与订阅，但 Nature 与消息系统存在着本质的不同。消息系统仅仅是一种技术形式，他允许开发者既是球员（功能开发）又是裁判员（目标数据定义）。其次消息是暂态的，消息与消息之间没有必然的相关性，消息系统的本质是解耦两个技术过程。而 Nature 是面向业务的，不关心技术形态，其中的数据是永恒的，数据和数据间存在强相关性。Nature 中的“选择”衔接的是两个目标而不是过程，衔接的是真个业务网中的一个一个的里程碑。

### `workflow` 和 `BPMN` 

从业务流程编排来看，Nature 与 `workflow` 和 `BPMN` 有一定的相似之处。其重要区别在于后者告诉我们**怎么做（功能性驱动）**，“怎么做”是非常复杂的，具象的，迭代多了我们的**目标可能会迷失**。而 Nature 告诉我**需要什么**，而“需要什么”是简单的但却是最为重要的更不会迷失，Nature 让我们**聚焦到真正重要的事情**上，并**让管理变得简单**。Nature 把怎么做交到了外部的 `Converter` 去处理，如何处理是不去管的。

### Faas 和 Serveless

Nature 和 `Converter` 协作的方式实际上可以看做是 FaaS(Function as a Service) 或者 Serveless 的一种形式，但我不想使用这个概念，因为`FaaS` 不是这个项目的主要设计意图，我没有看到 `FaaS` 是如何管理业务目标的。

## 深入了解Nature

[示例及功能讲解](https://github.com/llxxbb/Nature-Demo)

[架构说明](doc_zh\help\architecture.md)

`Meta`的具体使用方法请参考：[使用 Meta](doc_zh/help/meta.md)

`Relation`的具体使用方法请参考[使用 Relation](doc_zh/help/relation.md)

`Converter`的实现方法请参考[实现`Converter`](doc_zh/help/converter.md)

本系统还处于早期阶段，有不妥之处，还请多提建议。

