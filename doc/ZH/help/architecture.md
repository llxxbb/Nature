# Nature 架构

在阅读之前请先阅读[README](../../../README.md)。

## Nature 的自然观

Nature 是为了简化业务问题而提出的，既要使用简单又能承载复杂的业务其实是蛮难的，还好中国古人的智慧已经有现成的遗产可以借鉴。《易传》有云：“易有太极，是生两仪，两仪生四象，四象生八卦”，这是诠释《易经》的，《易经》的博大精深在这里自然无法体现的，但其简单、朴素的模型对 Nature 的架构有着直接的指导意义。因为它正好满足我们的核心诉求：**用简单的模型表示复杂的事物**。

Nature 并不是《易经》的系统化，《易经》虽然形式上简单，但要想运用自如绝非等闲之辈，因此请放心，这不是一个玄学系统。除了本文用于说明 Nature 的设计理念外，Nature 的其它文档都不会引用《易经》的任何内容。本系统之所以命名为 Nature 也有摒弃玄学之意，同时也期望像《易经》那样可以有非常广泛的适用范围。

### 两仪

我们先用《易经》中的两仪来解决第一个复杂度也是最为核心的一个复杂度：**业务系统的划分**。

传统的业务系统大都是按业务的垂直领域进行划分的。拿电商来举例，系统是按领域直接划分的，大体上可以分为交易、库房、配送、售后、财务、用户等等。这样的划分非常的直观，而且很多情况下组织机构的划分也是这样的。这可以说是业界的普遍常识，这很符合面向对象的设计方法，但有人已经对此进行了深刻的批判，请参考《[面向对象编程—价值万亿美元的灾难](https://www.toutiao.com/i6788266897667260931/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1595718883&app=news_article&utm_source=weixin&utm_medium=toutiao_android&use_new_style=1&req_id=202007260714430100150420261F6A5C4D&group_id=6788266897667260931)》，Nature 则给出了自己的反对意见：

这样的划分会要求每个业务系统都有一套完整的**决策和执行机制**，对于一个系统来讲这两者是无法分割的，因为它们共同耦合到一套代码里所以是一体的。这可以看做是面向对象编程里的数据和方法，数据是目标既决策，方法既执行。这种耦合会对我们的功能迭代造成很大的困难，当一个系统的决策改变，不可避免的与其它系统的执行产生纠葛，这就要考虑系统平滑过渡和兼容性问题，就会形成难以去除的阶段性代码，就会造成系统的臃肿和难以维护。所以大的电商平台都有几千的开发人员来支撑这些系统。这虽然可以通过良好的设计来规避一些问题，但对于初期快速发展的业务来讲很难预测哪个是好的设计，稍纵即逝的商机也很难让我们一开始就有一个完美的设计。



对于业务来讲，Nature 认为两仪是**决策和执行**。

对于以人为核心的组织机构来讲可能是一种不错的模式，但对于系统而言就不是一件好事了。

这是一种严格的以2为指数的变化，计算机的发展遵循着这个规律





因为这要求每个职能系统都有相互间独立的的决策和执行能力，现实的系统绝大多数也确实是这样，

这两种能力是一起被固化到代码里的，是无法独立变化的，这对决策的调整是非常不友好的。

但这不是两仪，



我们再从微观上分析，在常识上一个系统的诞生都遵循设计、实施、运行这几个独立的阶段，如果把设计过程看做是决策，把实施和运行看做是执行，也是符合两仪逻辑的。但**问题不在于过程的独立，而在于产物的独立**。传统系统设计的最终产物是代码，这就与运行耦合在一起了。为什么这么说呢？因为代码里有思想和决策，同时又是执行机构。虽然这有点违反直觉，但“最好的文档就是代码”已经说明了问题，所以**传统业务系统是无法形成独立的两仪的**。这也是当下无法回避和减轻的本质缺陷。

为此 Nature 提出了自己的方案。在 Nature 体系下设计的产物最终产物不是代码而是 `Meta` 和 `Relation`，这两个东西是独立于代码之外的且是可以灵活定义和变迁的，同时又对执行的结果有100%的约束力，因此 Nature 可以用两仪来驱动整个业务体系的不断发展和变化。



## 未整理



Nature 就是按这个**自上而下**的思路来帮助您构建整个业务系统。

面向对象的方法是将数据和功能封装在一起。



### 四象

虽然 Nature 提供了功能强大的两仪，但因为两个维度还是过于粗放，无法具象化，因此您看到了 Nature 用 `Meta` 和 `Relation` 一起来表示设计时，这样就可以将设计具象化了。如果说设计时和运行时是两仪中的一阴一阳，那么 `Meta` 和 `Relation` 就是设计时的一阴一阳，当然您也可以将它们看做是两仪。

我们现在来看一下 `Meta` 和 `Relation` 这两仪所起的作用。对决策来讲最重要的是我们要达成的目标，以及完成这些目标的方法和规则，这里 `Meta` 对应的就是目标，而 `Relation` 则对应的就是方法和规则。对于一个软件系统来讲目标就是数据，而这里的数据是泛指而不是某一特定的实例数据，因此 Nature 称之为 Meta，而规则和方法必须需要施加在多个数据之上，因此数据间必然存在 `Relation`，因此 Nature 使用 `Relation` 来承载规则和方法。

我们现在来看下四象中剩下的两象，自然这两象位于运行时。但与设计时相同的是，这两象也是数据和方法。但这里的数据是 Instance 数据 ，而方法则是用于执行规则的代码系统。只不过这些方法需要 Nature 外部来实现了，请放心这个实现已经非常的简单，因为复杂的业务耦合已经放到设计时的 Relation 中去了。

这样 Nature 基于这四象便可以承载千变万化的业务了。





如果将这个业务系统进行。 如果将这个 业务域是“空间”问题，处理流程是“时间”问题。下面我们来详细分析一下。

### Nature 的空间

《易经》时用来推演世界空间、时间各类事物关系的。而 Nature 则是将之系统化的， 

Nature 的空间并不是传统意义上的三维物理空间，而是逻辑空间。她代表着结构、规则，用于对功能进行支撑和制约。Nature 空间的意义在于：

- 唯一标记一个业务对象，以便于Nature 区别对待每个业务队形，这有点类似于命名空间，Nature 用`Meta`来标记一个业务对象。
- 对业务对象进行定义和验证，以说明该业务对象应该具有的样子，**此功能暂未实现**。
- 建立起业务对象之间的联系，便于对业务结构进行支撑，并为系统的运转提供规则，Nature 用 `Relation`来表示业务对象之间的关系。

对于一个物理世界来讲，我们一般用点、线和面来表示一个物体，在 Nature 中也存在着点、线和面。Nature 用 `Meta` 来构造点，代表了业务对象；用 `Relation` 来构造边，代表了业务对象之间的关系；Nature 的面则是隐式的，用于表示业务域，业务域由`Meta#key`来间接表示。将所有的点、线、面组织在一起就会构成一个完整的业务模型。

### Nature 的时间

Nature 的“时间”也并不是指传统意义上的物理时间，她代表着运转、秩序、不可变更的历史和演进：

- 运转：只有运转起来的结构（空间）才能行施功能。Nature 用 `执行器`来保障业务系统的运转的，Nature 为业务系统的稳定运转提供了一些重要的保障措施，如幂等、重试、异常处理等。
- 秩序：`执行器`没有流程控制功能，`执行器`之间的执行顺序是用`Relation`来保证的，`Relation`实现了传统的业务流程控制功能，有别于传统系统的硬编码方式，Nature 的流程控制不需要写代码，且是直观、可视、易用的。
- 不可变更的历史：运转结果的历史见证物是`Instance`， **其一旦生成将成为永不可篡改的历史**，即便是状态数据也可以进行回溯。
- 演进：业务是需要发展变化的，Nature 用`Meta#version`来承载业务对象定义的版本变化，既保证了既有业务的稳定，又为业务变更的灵活性带来便利。

## Nature 的运行机制

业务系统在运行之前需要对`Meta`和`Relation`进行定义，所以`Meta`和`Relation`可以认为是`设计时`，而`执行器`则可以认为是`运行时`，`Instance`则是运行时的产物。`Meta` 和 `Instance`，相当于编程语言中的 `Class` 和 `Object`。

Nature的`设计时`对`运行时`拥有**完全支配能力**。`Meta` 用于限定`运行时`生成什么样的`instance`。`Relation` 用于说明在`运行时`应提供什么样的`Instance`来生成另一种`Instance`，也就是说Nature 的**`Meta`和`Relation`是整个业务系统的指挥中心**。

业务流程中真正做事情的是`执行器`，`执行器`会在合适的时候被 `Relation`唤起并执行。`执行器`也是Nature中唯一需要程序员编码的部分。`执行器`只处理特定业务领域本身的逻辑，`执行器`之间是不需要直接通讯的。

### Nature 运行机制的数学表达

Nature 的运行机制可以用一个数学公式来表达 : y=f(f(f(...f(x)...)))。

每个`Relation`都可以表示成y=f(x)，上游`Relation`的输出可以作为下游`Relation`的输入。其中x,y都是`Instance`，而 f 则是`执行器`，`执行器`可以看做是传统意义上的接口，接口在传统开发方式中具有举足轻重的地位，是功能间协作的桥梁，但`Relation`将接口的重要性弱化了，这反应在以下几个方面：

#### 去功能化

传统的接口是一种功能导向的产物，功能是目标的实现，所以功能是现象级的，你得经过分析才知道它要干什么，甚至有时候会发现不知道它在干什么，或者为什么这么干。目标是一个点，而功能是一条线，所以对于一个复杂的业务系统要想厘清这些接口是件非常困难的事情。而Nature 不是面向功能的，而是面向目标的，她将传统系统本末倒置的**功能与目标的从属关系进行了正位**，使其有了“**自然**”的表达。

之所以能做到这一点，我们需要对`Relation`的数学形式再次解释一下，y=f(x)说明了我要借助于`执行器`来实现我的目的，而`执行器`如何实现是没有定义的，所以Nature才能够**用`Relation`把业务目标从幕后提升到了前台，用`执行器`把功能实现从台前压到了幕后**，实现了对功能实现的隔离。`执行器`只不过是一个无业务区别的纯技术上的一个接口，因此她无法限定业务目标，而`Relation`是可以限定目标的，目标限定了功能也就限定了。

有了这个拆分，我们就可以用`Relation`在**人机界面层面而不是代码层面**来处理核心的业务问题。我们只需关注业务对象之间的关系，而不用担心`执行器`这种实施层面的技术性的功能性问题，也不会再受功能的羁绊和掣肘，而且我们可以得到一个**极简但却够用且实用的系统蓝图**，这将大幅度减少系统的复杂度并降低成本开销，这无疑是对传统系统的一种巨大变革，也许从此功能化系统将走下历史的舞台。

#### 去中心化

我们上面说过，上游`Relation`的输出可以作为下游`Relation`的输入。这是一种串行的流式处理方式。只要上游`Relation`的输出`Meta`与下游`Relation`的输入`Meta` 一致，在运行时便可以一个接一个的自动流转并生成相应的`Instance`。这期间**不需要某一个或某几个点来进行任何的业务逻辑控制**，也就是说系统的行为是下游自由发挥的，是不受控制的，是去中心化的。

去中心化在一个大型系统里意义是非凡的。主要体现在以下几个方面

- 效率：去中心化，意味着路径数量会减半，意味着用更短的时间更少的资源就能完成任务，意味着更少的成本。
- 分布式：没有了中心，也就避免了集中所特有的拥堵隐患，能够充分发挥分布式水平扩展的潜力。
- 自适应：控制的去除，就有了更多的灵活性，就可以自由的调整自己；再加上成本的减少，就有了更多尝试来完善自己做好自己。

#### 一对一

`Relation`只允许一个输入对应一个输出，既一对一，一对一的做法借鉴于关系数据库，Nature 用一对一来表示所有`Meta`间的关系。之所以用这样的形式，除了形式简单外还有以下几方面原因。

- `Relation` 是纯粹的`数据流`，这种纯粹的数据流非常适合用来表示业务对象的来龙去脉。
- **将复杂关系解耦**，Nature 只需要维护一堆的一对一的`Relation`。这看起来很松散，但Nature 会自动组装它们，让它们“**涌现**”出一个复杂的整体，以形成一种**强有力的无形控制力**。这很像蜂群或蚁群的工作方式，这种方式将大大简化复杂业务模型的构建方式以及提供强大的灵活性。
- 一对一模型能简化Nature 的运转控制逻辑，因为`执行器`形式的简单、统一，我们就很容易在`执行器`上施加`切面`技术，赋予 Nature 很多增值功能，如并发、幂等、重试等，从而大幅度降低系统的技术复杂度，使开发者能够更好的将精力聚焦到业务本身上。

### Nature 运转机制的哲学意义

除了技术意义之外，Nature 的运行机制还透射出哲学意义，这里我们讲一下**选择**和**控制**的区别。

#### 控制

控制是实现目标所采取的手段和方法。传统系统大多是基于控制的。代码控制一切，这是编程这个行业诞生以来天经地义的一件事情，无论是框架、设计模式、组件都是一种控制，包含 Nature 本身也是控制的产物，不过Nature 是为了减少后续代码控制而诞生的。

代码是思想的产物，思想有多复杂代码就有多复杂。而思想是灵活的，所以构建出复杂的系统也就不奇怪了。从另外一个角度来讲，这种灵活性也是一种灾难！比如拿团队协作来讲，通常情况下我们只能有限度的统一我们的思想。为了提高思想的统一度，现在有专门的学科和开发模式来应对这个问题，可想而知控制的复杂度有多高。控制是自上而下的，是一对多的。下游的每一个变化，都需要**反馈**到上游进行协调处理，而反馈处理尤其复杂。

#### 选择

选择与控制相反，它是自下而上的，上游不会去控制下游，而是下游自行选择上游，就像一条河一样，上游是无法控制下游的流向的。因为上游不去控制，下游也没有必要将信息**反馈**到上游。`Relation` 的形式决定了她不允许控制只允许选择。`Relation`不只是选择上游，他还选择`执行器`，这样就可以实现“功能”随意替换。

从复杂度上来讲控制额外需要反馈，尤其是多级反馈的情况将更为糟糕。而选择只有执行这一步。所以选择既提升了性能，又给了下游充分的灵活性；下游可以方便的决定自已的意图，掌控自己的命运。

其实Nature的选择还可以进一步细化，如对上游的状态和上下文做出选择。这里举一个支付和发货的例子：当支付状态为“已支付”则生成出库申请单，如果没有支付完成则不动作。如有用代码来描述的话这里很明显需要一个`if`控制语句，但在Nature 里没有`if` 控制语句，你只需要定义一个“支付状态=已支付->出库申请单”的 `Relation`就可以了，if 的控制由Nature 来帮你完成。我们再举一个上下文的例子:订单开发票。我们可以建立一个这样的`Relation` ：订单.context.发票=true -> 发票申请，同样的，这个任务不用开发人员进行流程控制。

#### 生态与法则

在一个生态系统里没有一个至高无上的主可以控制所有的一切，每一个物种都在选择中适应，这样才有了生物的**生机勃勃**和**多样性**。请注意生机勃勃和多样性两个词，这是目前传统系统所欠缺的。传统系统之所以死气沉沉，低效，就是因为自上而下的控制，类似于公司业务的层层汇报、层层审批，**当控制的链路非常长非常广时，由控制导致的内耗将十分突出**。

对于一个个体而言，要想对其控制，必须对其所控制的资源进行某种形式的**占有**，控制的能力和范围与资源占有程度是紧密相关的。而占有是具有**侵入性**的，而侵入是有成本的。但选择只要对方存在就可以，不需要侵入，所以不需要额外的成本，既**选择比控制对环境的要求要低很多**。

Nature 是适合于大型业务系统的，这是 Nature 的选择特性所赋予的。因为没有控制，你不会遇到复杂的逻辑问题，诸如分支、循环、跳转等；因为没有控制，系统的演进成本将会非常低廉，业务模块间的链路能方便的重组并容易找到最优路径；因为没有控制，各种各样的业务模块可以自由的试错和扩展，以灵活的方式去匹配业务发展的需要。

虽然这里不强调控制，但万物运转如何保持其秩序呢？那就是法则。没有控制并不代表着没有法则，法则不是控制，控制有着明确的目的，而法则没有目的性。地球之所以围绕太阳转，不是太阳有意控制地球，而是万有引力法则在发挥作用。自然界的生态系统也是一样的，春夏秋冬、寒暑易节、昼夜轮回维系着自然生态的平衡。对于 Nature 来讲维系系统运转的法则便是 `Relation`，只要遵循Nature 的法则，我们就可以摆脱代码控制的繁琐、脆弱和低效，并拥有一个充满生机的且能够承载业务多样性的业务生态系统，

### Nature 运行机制的技术意义

在传统系统中流程控制是用代码来控制的，而Nature只需要定义`Relation`就可以对流程进行“**实际控制**”，不需要编码来实现，这行方式带来的好处是：

- 降低设计成本：传统系统一般都会由需求团队、技术团队不断碰撞来完成一个设计，不管是人力还是时间上都有很多的成本。而 Nature 的设计完全是面向业务的，不需要这么多的人力和时间成本。另外在技术上因为Nature 承担了足够多的技术支撑能力，所以技术上的设计工作会大幅度降低，甚至可以忽略。
- 解耦了`设计时`与`运行时`：传统方式下代码既是`设计时`又是`运行时`，所以流程控制的改动非常困难，而Nature 的`设计时`与`运行时`是隔离的，不管是业务迭代还是技术迭代都具有很好的灵活性。
- 使设计具有**实际控制**能力：在传统系统中，代码是实际的控制者，设计只是指导，尤其在经过多次迭代之后，两者的匹配度将会变得更为糟糕！而Nature的设计可以做到100%的控制能力。`Meta`和`Relation`直接参与到`运行时`，并对`运行时`指挥和约束`执行器`。
- 职责单一的`执行器`：在 Nature 环境下，由`Relation`进行整体控制，`执行器`之间不需要通讯，不需要考虑上、下游控制问题。也就是说我们的代码不需要关注流程控制，非功能需求也已经由Nature 代劳，这就大幅度较少了代码量，同时间接提高了系统的稳定性和可维护性。

### Nature 法则所体现出来的无形控制

在 [Demo](https://github.com/llxxbb/Nature-Demo) 中 涉及到网购和统计相关的示例，这些示例说明了 Nature 如何简化这些业务的实现。在这里不做具体展开，这里只想说明一下选择机制如何有效支撑系统的运行秩序。为了简单起见，所表达的内容可能与Demo中的不完全一致，还请谅解。

上文中我们说到选择是下游对上游的选择，这就揭示了一种思考方式：**逆向思维**，既我们要达到目的需要什么。拿网购来讲，需要从流程的终点来倒推。用户若想拿到商品需要配送员送，交接数据为签收单，于是我们定义第一个`Meta`。然后我们再倒推，配送员需要和库房交接出库单才能拿到商品进行配送，出库单是我们的第二个`Meta`于是我们有了第一个`Relation` ： 出库单->签收单。

以此类推我们可以定义出类似于下面的`Relation`

```
出库单->签收单
订单->出库单
```

这里有个很重要的点需要说一下，从出库单到签收单如何调度的，是自己公司配送还是第三方配送这里并不关心，`Relation`的`执行器`想用哪个就用哪个。既`Relation`只关心结果，并不关心如何做。

这样一个简单但完整的`设计时`便出来了。而这个设计不用代码就实现了对`运行时`的控制。

像 `Relation` ：出库单->签收单 在`设计时`是一对一的关系，在`运行时`产出的`Instance`也是一对一的,既一张真实的出库单会对应一张真实的签收单。这在 Nature 里是最为常规的控制。其它控制方式都是由这种常规方式支撑的，如接下来要讲的分流。

设计时的分流的形式是不同的下游拥有同样的上游，就像河流分叉一样。如上面的出库单还可以驱动库存状态，`Relation` 如下：

```
出库单->签收单
出库单->库存状态
```

在此种情形下，出库单不需要知道有多少个下游，但Nature 会知道，因此Nature 需要在幕后分别执行每个`Relation`的`执行器`。

注意这里的“出库单->库存状态”，这个在`设计时`是一对一的，但在`运行时`却有可能是多对一的。举例说明一下，假设在`运行时`我们有两个出库单，出库单1包括2个手机，出库单2包括3个手机，但却只能有一个手机的库存状态，所以在这个示例里就有了两个出库单实例分别对应同一个库存状态的不同版本的实例数据。（有关状态数据及状态的并发控制请看下面技术特性小节）

那么有没有`运行时`是一对多的呢？这里有个例子：订单->支付单。这在`设计时`是一对一的，但在`运行时`是可以一对多的。假设用户第一张卡里的钱不够支付订单，这时候就会有多次支付的情形存在了，既一个订单实例对应多笔支付实例。

那么在`设计时`有没有多对一的情形呢？答案是有的，`Relation`定义如下：

```
CPU->主机
内存->主机
```

现在我们来看，`设计时`的一对多、多对一，`运行时`的一对多，多对一，可以随意搭配组合，这就在理论层面形成了完整的闭环。这样`Relation`就可以支撑非常复杂的业务。但对于使用者来讲基本上不用关心流程控制问题，使用者只需要做出合理的选择，大自然（Nature）便会在法则（`Relation`）下无形中操控一切。

## 技术特性

在传统系统里，**要想保持数据一致性是一个非常具有挑战性的任务，当面对多个系统协作并保持整体一致性时问题会更加困难。**就个人的经历而言，我们大部分的工作都会消耗在这上面。导致不一致的原因可能是因为设计不到位，但更多的原因可能在于要实现一致性开发代价非常高。目前还没有见到有统一的、简单易用的、高效的、开箱即用的解决方案面世。Nature 诞生的目的，就是让使用者聚焦于业务而非技术，为了到达易用的目的，Nature 就装必须封账这些技术复杂性，包括辣手的数据一致性问题，下面我们分别来看一下：

### 数据的不可变性

Nature 只能插入数据不能变更数据，`Instance`一旦生成既被永久定格，这就防止变更导致的数据覆盖问题。这一特性使得 Nature 可以被信赖，因为生成的数据不可抵赖，且可以溯源。这就要求数据是无状态的，但 Nature 是支持状态数据的，如何解决这个逻辑相悖的问题？答案是版本。Nature 为状态数据的每一次状态变更都会生成一个新的`Instance`，但这些不同状态的`Instance`拥有相同的ID和`Meta`，只是版本号是不同的。上面提到的主机组装中的主机便是一个状态数据的例子。cpu 会形成一个主机的状态数据，内存也会形成一个主机的状态数据。这两条状态数据拥有相同的ID，但版本号不同。

### 防重机制

Nature 需要面对下面情形所产生的问题：

- 并发冲突
- 环境变化

我们先看第一种情况，Nature 是**事件驱动**的，既然是事件，就无法确定触发的时机，就可能出现并发冲突问题。还拿主机装配来讲，cpu 和内存有可能同时触发主机状态数据的版本变更，很显然我们只能让一个成功，另一个失败。Nature 內建了版本冲突的控制，无需`执行器`进行干预，除非外部直接输入。其实现机制是这样的，如果下游数据是状态数据，Nature 在调用`执行器`之前先取出下游状态数据并记录版本号，然后Nature 再调用`执行器`，当`执行器`返回状态数据后，Nature 会将之前记录的版本号+1 赋值给新返回的状态数据，当+1版本的数据已经存在时即可识别为冲突。冲突处理是Nature 內建的功能，`执行器`无需关注。

第二种情况可以举一个库存的例子，上一时间可能有库存，但可能下一时间就没有库存了。环境往往是脆弱的，如网络超导致Nature 重试，那么我们要如何对待同一调用的在不同时刻的不同的结果呢？依据数据不可变性 Nature 会舍弃后续的结果，从而保证 Nature 调度的**幂等性**。为了实现调度的幂等性，Nature 提供了以下措施和建议。

- 主键防重：`Instance` 数据表的主键构成为 ID + `Meta` + 状态版本。
- 预分配ID，在调用Nature 之前预先生成一个ID，或许 facebook 的 snowflake ID 生成器算法是一个不错的选择。使用此ID作为`Instance`的ID，这样当出现环境问题时使用相同的ID提交数据到 Nature 就不会存储多条数据了。如果你不提供ID，Nature 会使用哈希算法为你生成一个。

### 任务分发与`Instance`

调度的幂等性几乎遍及Nature的所有运行过程，这里我们讲一下任务分发。举一个例子：一个上游有两个下游跟随者，生成第一个下游时失败了，但第二个却成功了；这时候我们做了一个“危险”的操作，把第一个下游和上游的关系删除了；这时Nature正在重试失败的第一个分支，砰！相同的输入不同的输出！所以Nature 必须避免此类事情的发生。**Nature 的做法是将关系产生的所有的任务数据都落盘**，这样当关系改变时，就不会影响到已经生成的任务数据。

但是如果网络很糟的话，Nature 可能会重复生成任务数据，而这也有可能导致不幂等，所以任务数据本身也需要防重设计，防重的依据就是上游`Instance`的ID。

### `执行器`与`Instance`

执行器细分有三种：

- 前置执行器：在转换之前可以对上游数据进行编辑，如格式转换等。
- 核心执行器（或称之为转换器）：实现上游 Instance 到下游 Instance 的转换。
- 后置执行器：可对转换后的 Instance 进行编辑。

其实不引入前置、后置执行器也是可以的，完全可以使用多个`关系`来解决。之所以引入前置、后置执行器是基于以下几点考虑的。

- 关系主要说明业务实体间的关系，具有业务语义。而前置、后置执行器一般是技术性处理，如果使其关系化，则由关系所呈现出来的业务图会不纯粹和令人费解。
- 从性能上来讲，前置、后置执行器作为中间结果不会落盘，因此要比`关系`占用更少的资源。

Nature 是一个平台，她可能面对海量的数据和高并发的情景，在这种场景下最好的选择是使用分布式数据库。因为是分布式数据库，事务可能不被支持，在此种情况下如果`执行器`返回多个`Instance`，Nature 必须一条一条的保存这些数据，而这个过程可能被坏的网络环境打断，被打断的任务会被Nature 重新唤起，既`执行器`重新执行了一次任务，而Nature 不能要求`执行器`本身具有幂等性，于是问题出现了：`执行器`可能返回与上次不同的数据！

与任务分发一样，Nature 使用`任务`来解决这个问题，`任务`的内容包含了所有从`执行器`返回的`Instance`。Nature 在逐条保存`Instance`之前先保存这个任务。这样如果被打断，Nature 只需要从任务中取出所有的`Instance`重新保存一下就好了。

### 错误、回调

Nature 为`执行器`定义了两种类型的错误：

- `LogicalError`
- `EnvironmentError`

如果`执行器`遇到一个未定义的错误并且应该中断处理，他就可以返回一个`LogicalError`，接下来Nature 会将这个任务从`task`数据表转移的`task—error`数据表，并且不会尝试重新执行这个任务。

然而有些`执行器`因为执行时间很长，所以无论你重试多少次都无法成功，为此Nature 提供的 回调机制来解决这个问题。当遇到这种情况是，`执行器`的实现者需要开启一个独立的线程去执行具体的任务，并立即返回一个异步处理信号及可能返回数据的时间给Nature，Nature 会依据此时间推迟下次重试的时间； 当`执行器`真正完成任务时，`执行器`的实现者需要主动调用Nature `callback`  接口并传入处理结果。

转移到`task——error`数据表中的任务都会记录失败的原因以便于使用者进行检查。

### 重试

Nature 在与`执行器`通信或者进行自身调度时会自动捕捉`EnvironmentError`。针对 `EnvironmentError` Nature 实现了一套机制来多次重试，当所有的重试都失败的时候，任务会从`task`数据表转移的`task—error`数据表。

重试可能会产生重复的`task`和`Instance`。如果检测到重复的  `task` 可以直接中断处理， Nature 有独立的重试模块会继续处理。如果检测到重复的  `Instance` 则需要将原有的 `Instance`取出来替换掉当前的 `Instance`并继续后续处理，而不能像 `task` 那样中断处理，因为如果中断就无法形成后续的 `task`。

### 历史回溯

`Relation`可以构建出一张现在运行的业务网。但具体到某一笔业务，要想给出这笔业务是走的业务网中的哪一条或哪几条线路，对于`Relation`来讲是不合适的。Nature 用`Instrance`的`from`属性来解决这个问题，该属性记录了它的上游`Instance`。这样就可以非常方便的知道该笔业务的来龙去脉了。这对于传统业务系统来讲是件非常困难的事情，如需要在不同的页面来回跳转，非常不直观，也非常难于排查问题，这是因为传统业务系统没有统一的处理模型，要做到像Nature 这样易用的程度，非常困难。

### 批处理

假设我们要统计一下一个火爆的电商网站的单品销售 top, 每次统计可能涉及到千万数据，传统的基于 sql 的统计已经不太现实。对于这个问题 Nature 提供了一套自己的解决方案。Nature 提供了一个专有的 `MetaType::Loop` ，Loop 可以**驱动**一次处理一批数据。有两种处理模式：

- MetaSetting.only_one = false

```
Upstream -> Loop + downstream
Loop -> Loop + downstream
...
Loop -> downstream
```

- MetaSetting.only_one = true

```
Upstream -> Loop
Loop -> Loop
...
Loop -> downstream
```

**注意**：对于 `MetaType::Loop` 来讲 `MetaSetting.only_one`如果设置为 true, Nature 会将要输出的 Instance 视为有状态的，只有这样才能实现结果的叠加，才能完成形如 input + old = new 这种形式的数据处理。但你不能把`MetaType::Loop` 的目标 Meta 设置为有状态的！因为从 Nature 外部来看我们只要一个最终结果而不是中间结果，如果置为状态数据会让人感觉到非常奇怪。为了实现这种效果，Nature会把中间结果作为 last_state 数据并带到下一个批次里处理直到完成为止。

批量的控制则来源于 Nature 的一个[内置执行器](built-in.md)：`instance-loader` 后面有这样的示例，请参考：[示例及功能讲解](https://github.com/llxxbb/Nature-Demo)。

### 上下文

上下文可提供额外的控制手段，如可通过上下文来编辑流程控制。上下文的另外一个好处是，使得业务数据更加纯粹，使得控制数据和业务数据完全分离。

上下文分为`系统上下文`和`用户上下文`。用户上下文是用户可以自行定义的，而系统上下文是 Nature 自身定义的。系统上下文在Nature 的功能构建上起到很重要的补充。如`MetaType::Loop` 和 `instance-loader` 的协作就用到了三个系统上下文：

- loop.next：用于控制下一个批次的开始 instance 条件
- loop.task：用于传递批数据的处理规则，因为只有第一个批次可以取得处理规则。
- loop.finished：标记所有批次是否处理完成。

除了这些外，还有用于桥接的系统上下文：`target.id` 和 `target.para`。当有 A->B->C的链路时，C想使用A的ID作为自己的ID,而B没有使用A的ID，这时候就需要B架一个桥了。当B为另一个体系的数据时会有这个问题。请参考：[示例及功能讲解](https://github.com/llxxbb/Nature-Demo)。

还有用于动态参数替换的系统上下文：`para.dynamic`。一般我们在配置 Relation 数据时，都是定义好的固定内容。但有时候我们需要运行时确定一些参数，这时候就需要该上下文了。


## 可扩展性

### 业务的扩展性

`Meta` 可以通过版本技术来实现业务的变迁或发展。

### 技术扩展性（还未实现）

Nature 是面向业务的一个开发平台，并用简单的方式构建业务模型。她使技术和业务能够很好的解耦，这使得很多技术不用受限于具体的业务，同时又可以用统一而简单的方式来强化业务的能力，如监控、权限管理、可视化等。

