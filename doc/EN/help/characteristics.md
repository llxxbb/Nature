# Nature technical features

Nature aims to enable users to focus on business rather than technical. To reach ease of use Nature seals many technical complexities to ease the burden on technicians. 

This includes **data consistency** problem which is difficult to achieve across multiple systems in traditional ways. Heterogeneous problems, network problems and robustness problems of systems are all considered content in data consistency, more systems more complexity. There hasn't been a unified efficient and out-of-box solution yet, that is an important cause of creating Nature. 

Let's look at what technical capabilities Nature provides for us:

## Immutability and idempotence of data

Nature can only insert data and cannot change the data. Once the `Instance` is generated, it is permanently frozen, which prevents data overwriting problems caused by changes. This feature makes Nature can be trusted, because the generated data is non-repudiation and traceable. Another important application of data immutability is idempotence.

In order to achieve idempotence, Nature provides the following measures and suggestions.

- Primary Key: The primary key of the `Instance` data table is composed of ID + `Meta` + `Para` + status version.
- Pre-allocated ID: Generate an ID before calling Nature. Maybe facebook's snowflake ID generator algorithm is a good choice. Use this ID as the ID of the `Instance`, so that when there is an environmental problem, using the same ID to submit data to Nature will not store multiple data. If you do not provide an ID, Nature will use a hash algorithm to generate one for you.
- Para: para is useful when importing external data into Nature. At this time, Para can be the external data's ID that uniquely identifies the external data. If para is used, the ID of `Instance` is set to 0 in general.

Nature supports state data, so how does Nature ensure that the data is not modified? The answer is version. Nature generates a new `Instance` for each change of the state data, but these `Instance`s in different states, they have the same ID and `Meta`, but the version number is different. Such as the order status in [Demo](../../../nature-demo/README_EN.md).

## Rewriting protection

Nature needs to face the problems arising from the following situations:

- Concurrency conflict

- environmental change

Let's look at the first case first. Nature is **event-driven**. Since it is an event, it is impossible to determine the time of the trigger, and concurrency conflicts may occur. If the outbound order and the inbound order operate on commodity inventory at the same time, obviously we can only make one succeed and the other fail. Nature has built-in version conflict control, without the intervention of `Executor`, unless input directly from outside. The implementation mechanism is like this. If the downstream data is status data, Nature will take out the last downstream status data and record the version number before calling `Executor`, and then Nature will call `Executor`. When `Executor` returns the status data, Nature will increase the recorded version number to the newly returned status data. When the +1 version data already exists, it can be identified as a conflict, and when conflict Nature will pick the last again and call `Executor` again until it is success. Conflict handling is a built-in function of Nature, so there is no need to pay attention to `Executor`.

The second case is also relatively common. For example, the network is often unstable, in which case Nature will try again. But there is a kind of instability of the business scenario, such as the inventory is not available at this time but it will be Ok at the next moment. At this time, the control is in the Executor. If you want to try again, it would return an environment error, if you don't want to try again, it would return a logic exception.

## Task Distribution and `Instance`

The idempotence of scheduling covers almost all the running processes of Nature. Here we talk about task distribution. Take an example: an upstream has two downstream followers, and it fails when generating the first downstream, but the second succeeds. At this time, we have done a "dangerous" operation, we removed the combining of the first downstream with the upstream, then Nature retry the first branch that failed, bang! The same input but different output! So Nature must avoid such things from happening. Nature's approach is to package all the task data generated by the relationship together, so that when the relationship changes, it will not affect the task data that has been generated.

But if the network is bad, Nature may repeatedly generate task data, which may also lead to non-idempotence. Therefore, the task data itself needs to be designed rewrite protection. The basis way is the ID of the upstream `Instance`.

## `Executor` and `Instance`

There are three types of Executor:

- Pre-Executor: You can edit upstream data before convert it, such as format conversion.
- Core Executor (or converter): Realize the conversion from upstream Instance to downstream Instance.
- Post Executor: Edit the converted Instance.

In fact, it is also possible not to introduce the front and rear Executor, and it can be solved by using multiple `Relation`. The introduction of the front and rear `Executor` is based on the following considerations.

- Relationship mainly describes the relationship between business entities and has business semantics. The front and rear Executors are generally technical processing. If they are relational, the business graph presented by the relation will be impure and confusing.
- In terms of performance, the front and rear Executor will not be stored as an intermediate result, so it takes up less resources than `Relation`.

Nature is a platform that may face massive amounts of data and high concurrency scenarios. In this scenario, the best choice is to use a distributed database. Because it is a distributed database, transactions may not be supported. In this case, if `Executor` returns multiple `Instance`, Nature must save these data one by one, and this process may be interrupted by a bad network environment. The interrupted task will be re-evoked by Nature. That is, `Executor` performs a task again, and Nature cannot require `Executor` to be idempotent. So the problem arises: `Executor` may return different data from the last time!

As task distribution, Nature uses `task` to solve this problem. The content of `task` includes all `Instance` returned from `Executor`. Nature saves this task before saving `Instance` one by one. In this way, if it is interrupted, Nature only needs to take out all the `Instance` from the previous task and save it again.

## Error, callback

Nature defines two types of errors for `Executor`:

- `LogicalError`
- `EnvironmentError`

If the `Executor` encounters an undefined error and should interrupt processing, it can return a `LogicalError`, and then Nature will transfer the `task` from the task data table to task-error data table, and will not try to perform this task again.

However, some `Executor` cannot succeed no matter how many times you retry because of the long execution time. For this reason, Nature provides a callback mechanism to solve this problem. When encountering this situation, the implementer of `Executor` needs to open an independent thread to perform specific tasks, and immediately return an asynchronous processing signal and possible time to return data to Nature, and Nature will postpone the next time based on the time returned; when the `Executor` actually completes the task, the  `Executor` needs to actively call the Nature `callback` interface and pass in the processed result.

All tasks transferred to the `taskâ€”error` data table will record the reason of the failure for the user to check.

## Retry

Nature will automatically catch the `EnvironmentError` when communicating with `Executor` or scheduling itself. For `EnvironmentError` Nature implemented a mechanism to retry multiple times. When all the retries fail, the task will transfer to `task-error` data table from the `task` data table.

Retrying may result in duplicate `task` and `Instance`. If a duplicate `task` is detected, the processing can be interrupted directly, and Nature has an independent retry module to continue the subsequent processing. If a duplicate `Instance` is detected, the original `Instance` needs to be taken out to replace the current `Instance` and continue the subsequent processing, instead of interrupting the processing like the `task`, because if interrupted, the subsequent ` task` can't be generated.

## History back

`Relation` can build a current business network. But for a specific business, it is not appropriate for `Relation` to give out which one or several lines in the business network the business is going to take. Nature uses the `from` property of `Instrance` to solve this problem, which records its upstream `Instance`. In this way, you can easily know the ins and outs of the business. This is a very difficult thing for traditional business systems, such as accessing a link tracking system whose performance and data consistency cannot be guaranteed.

## Batch

Suppose we want to count the single product sales top of a popular e-commerce website. Each time the statistics may involve tens of millions of data, traditional sql-based statistics are no longer realistic. For this problem, Nature provides a set of its own solutions. Nature provides a proprietary `MetaType::Loop`, Loop can **drive** to process a batch of data at a time. There are two processing modes:

- MetaSetting.only_one = false

```
Upstream -> Loop + downstream
Loop -> Loop + downstream
...
Loop -> downstream
```

- MetaSetting.only_one = true

```
Upstream -> Loop
Loop -> Loop
...
Loop -> downstream
```

**Note**: For `MetaType::Loop`, if `MetaSetting.only_one` is set to true, Nature will treat the Instance to be output as stateful. Only in this way can the result be superimposed and can achieve input + old = new. But you cannot set the target Meta of `MetaType::Loop` as stateful! Because from the outside of Nature, we only need a final result instead of an intermediate result. It would be very strange if set to state data. In order to achieve this effect, Nature will use the intermediate result as last_state data and take it to the next batch for processing until it is completed.

The batch control comes from a [built-in Executor](built-in.md) of Nature: `instance-loader`. There are some examples behind, please refer to: [demo](../../../nature-demo/README_EN.md).

## Context

Context can provide additional controls, such as editing process control through context. Another benefit of context is that it makes business data more pure and makes control data and business data completely separate.

The context is divided into `system context` and `user context`. User context can be defined by users, while system context is defined by Nature itself. The system context plays an important supplement to the functional construction of Nature. For example, the collaboration of `MetaType::Loop` and `instance-loader` uses three system contexts:

- loop.next: used to control the start instance condition of the next batch
- loop.task: used to transfer the rules between batch data, only the first batch can get the processing rules.
- loop.finished: mark whether all batches are processed.

In addition to these, there are system contexts for bridging: `target.id` and `target.para`. When there is a link A->B->C, C wants to use A's ID as its own ID, but B does not use A's ID, then B needs to build a bridge. This problem occurs when B is the data of another system. Please refer to: [Demo](../../../nature-demo/README_EN.md).

There is also a system context for dynamic parameter substitution: `para.dynamic`. Generally, when configuring Relation data, we always define fixed content. But sometimes we need to determine some parameters at runtime, this time we need the context.

## Scalability

### Business scalability

`Meta` can realize business changes or development through version technology.

### Technical scalability (not yet implemented)

Nature is a business-oriented development platform and constructs business models in a simple way. It enables technology and business to be well decoupled, which allows many technologies not to be limited to specific businesses, and at the same time can use a unified and simple way to strengthen business capabilities, such as monitoring, rights management, visualization, etc.